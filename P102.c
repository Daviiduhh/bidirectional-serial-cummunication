/*
PRACTICA 10 - “COMUNICACION SERIAL BIDIRECCIONAL”
EQUIPO V 
8H1 - ELECTRONICA DIGITAL V
DAVID MADRID NAPOLES 17100201
CARLOS CAMACHO MATA 17100057
HECTOR SAMUEL RIVERA RUIZ 17100287
03/11/2020

*/

#INCLUDE <16F887.H>
#DEVICE ADC=8 
#USE DELAY(CLOCK=4000000)
#USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7,BITS=8)
#FUSES INTRC_IO,NOWDT,NOPUT,MCLR,NOPROTECT,NOCPD,NOBROWNOUT
#FUSES NOIESO,NOFCMEN,NOLVP,NODEBUG,NOWRT,BORV21

#USE FAST_IO(A)
#USE FAST_IO(B)
#USE FAST_IO(C)
#USE FAST_IO(D)

#INCLUDE <LCD1.C>

INT J = 0; //VARIABLES DE CUENTA
INT E = 0; //ENVIAR
CHAR R; //RECIBIR
INT DIGI = 0; //ALMACENA EL ADC

VOID INICIO (){ //MUESTRA LOS MENSAJES DE INICIO
   LCD_GOTOXY(1,1);
   PRINTF(LCD_PUTC, "      CETI      \n     COLOMOS    ");         
   DELAY_MS(500);
   
   LCD_GOTOXY(1,1);
   PRINTF(LCD_PUTC, "TGO. EN CONTROL \nAUTOMATICO E INS");         
   DELAY_MS(500);
   
   LCD_GOTOXY(1,1);
   PRINTF(LCD_PUTC, "   ELECTRONICA  \n    DIGITAL V   ");         
   DELAY_MS(500);
   
   FOR(J = 0; J <= 2; J++){ // EN CADA ITERACION MUESTRA EL R Y N DE UN ALM
      SWITCH (J){
         CASE 0:
            LCD_GOTOXY(1,1);
            PRINTF(LCD_PUTC, "DAVID MADRID     \n17100201            ");
            BREAK;
               
         CASE 1:
            LCD_GOTOXY(1,1);
            PRINTF(LCD_PUTC, "HECTOR RUIZ     \n17100287          ");
            BREAK;
                     
         CASE 2:
            LCD_GOTOXY(1,1);
            PRINTF(LCD_PUTC, "CAMACHO MATA     \n17100057         ");
            BREAK;
            }
      DELAY_MS(200);
   }
   
   LCD_GOTOXY(1,1);
   PRINTF(LCD_PUTC, "PRACT 10 COM SER\nIAL BIDIRECCIONAL");         
   DELAY_MS(500);
}
VOID READ_US (){ //LEE EL VALOR DEL ADC, LO GUARDA Y LO IMPRIME
   DIGI = READ_ADC();
   LCD_GOTOXY(1,1);
   PRINTF(LCD_PUTC, "VALOR ADC = %u       \n                "DIGI);
}

#INT_RDA //NECESARIO PARA LA SIGUIENTE FUNCION, VAN JUNTAS
VOID RDA_isr( ){ //se recibe un dato por el pin RC7 vía comunicación serial
   R=GETC();  //SE GUARDA EL DATO EN R
   LCD_GOTOXY(1,1);
   PRINTF(LCD_PUTC, "RECIBIENDO VALOR\n       = %c      "R);
   DELAY_MS(2000);
}//CUANDO RECIBE DATO INTERRUMPE EL PROGRAMA Y SE EJECUTA LA FUNCION

VOID MAIN (){ //FUNCION PRINCIPAL

   SET_TRIS_A(0XFF); //DECLARAR ENTRADA BOTON Y ADC
   SET_TRIS_C(0XFF); //DECLARAR COMUNICACION SERIAL
   
   LCD_INIT(); //INICIAR LCD
   SETUP_ADC(ADC_CLOCK_INTERNAL); //SE UTILIZA RELOJ DEL PIC
   SETUP_ADC_PORTS(sAN4); //SE HABILITA EL PUERTO 12
   SET_ADC_CHANNEL(4); //PUERTO QUE VA A TRABAJAR
   
   ENABLE_INTERRUPTS(GLOBAL); //Sirve para habilitar todas las interrupciones 
   ENABLE_INTERRUPTS(INT_RDA); //habilita interrupción por comunicación serial
   
   INICIO (); //MUESTRA MENSAJES DE INICIO
    
   WHILE (TRUE){ //CICLO INFINITO 
      READ_US (); //LEE ADC
      WHILE(INPUT(PIN_A7)==1){ //SI SE PRESIONA EL PIN 0 PUERTO A
         WHILE(INPUT(PIN_A7)==1){} //NO HACE NADA SI SE MANTIENE PRESIONADO
         WHILE(INPUT(PIN_A7)==0){ //CUANDO SE SUELTA
            E = DIGI;
            PUTC(E); //ENVIAMOS VALOR DE ADC
            LCD_GOTOXY(1,1);
            PRINTF(LCD_PUTC, "ENVIANDO VALOR =\n        %u       ", E);
            DELAY_MS(2000);
            BREAK; //DEJA DE MOSTRAR QUE ENVIA Y VUELVE A LEER EL ADC
         }
      }
   }
}
